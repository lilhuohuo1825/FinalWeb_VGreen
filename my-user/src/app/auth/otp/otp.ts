import { Component, OnInit, OnDestroy, ViewChildren, QueryList, ElementRef } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { AuthService } from '../../services/auth.service';

@Component({
  selector: 'app-otp',
  standalone: true,
  imports: [FormsModule, CommonModule],
  templateUrl: './otp.html',
  styleUrls: ['./otp.css'],
})
export class OtpComponent implements OnInit, OnDestroy {
  phoneNumber: string = '';
  otpDigits: string[] = ['', '', '', '', '', ''];
  otpError: string = '';
  countdown: number = 30;
  flowType: 'register' | 'forgot' = 'register';
  isLoading: boolean = false;
  currentOtp: string = '';
  private countdownInterval: any;
  private isVerifying: boolean = false;
  private lastInputValue: string[] = ['', '', '', '', '', '']; // Track gi√° tr·ªã tr∆∞·ªõc ƒë√≥

  @ViewChildren('otpInput') otpInputs!: QueryList<ElementRef<HTMLInputElement>>;

  private readonly OTP_LENGTH = 6;
  private readonly COUNTDOWN_DURATION = 30;
  private readonly SUCCESS_DELAY = 800;
  private readonly ERROR_DELAY = 800;

  constructor(private router: Router, private authService: AuthService) {}

  private generateRandomOtp(): string {
    const min = 400000;
    const max = 600000;
    let otp = Math.floor(min + Math.random() * (max - min + 1));

    if (otp % 2 !== 0) {
      otp = otp - 1;
    }

    return otp.toString();
  }

  goBack(): void {
    if (this.flowType === 'register') {
      this.router.navigate(['/register']);
    } else {
      this.router.navigate(['/forgot-password']);
    }
  }

  ngOnInit(): void {
    console.log('=== OTP Component initialized ===');
    console.log('Current path:', window.location.pathname);

    // ∆Øu ti√™n URL path ƒë·ªÉ x√°c ƒë·ªãnh flow type
    if (window.location.pathname.includes('forgot-password')) {
      this.flowType = 'forgot';
      this.phoneNumber = sessionStorage.getItem('forgotPasswordPhone') || 'Unknown';
      // console.log('üîç Detected FORGOT flow from URL');
    } else {
      this.flowType = 'register';
      this.phoneNumber = sessionStorage.getItem('registerPhone') || 'Unknown';
      // console.log('üîç Detected REGISTER flow from URL');
    }

    // console.log('‚úÖ Flow type:', this.flowType);
    console.log('Phone:', this.phoneNumber);

    this.currentOtp = this.generateRandomOtp();
    console.log('OTP L√Ä:', this.currentOtp);

    this.startCountdown();
    setTimeout(() => this.focusInput(0), 100);
  }

  ngOnDestroy(): void {
    if (this.countdownInterval) {
      clearInterval(this.countdownInterval);
    }
  }

  startCountdown(): void {
    this.countdown = this.COUNTDOWN_DURATION;
    if (this.countdownInterval) {
      clearInterval(this.countdownInterval);
    }
    this.countdownInterval = setInterval(() => {
      this.countdown--;
      if (this.countdown <= 0) {
        clearInterval(this.countdownInterval);
      }
    }, 1000);
  }

  resendOtp(): void {
    if (this.countdown > 0 || this.isLoading) return;

    this.isLoading = true;
    this.otpError = '';

    // Generate OTP m·ªõi
    this.currentOtp = this.generateRandomOtp();
    console.log('>>> NEW OTP:', this.currentOtp);

    // Clear inputs v√† reset
    this.clearOtpInputs();

    if (this.flowType === 'register') {
      this.resendRegistrationOtp();
    } else {
      this.resendForgotPasswordOtp();
    }
  }

  private resendRegistrationOtp(): void {
    const phoneNumber = sessionStorage.getItem('registerPhone');
    if (!phoneNumber) {
      this.otpError = 'Kh√¥ng t√¨m th·∫•y s·ªë ƒëi·ªán tho·∫°i ƒëƒÉng k√Ω';
      this.isLoading = false;
      return;
    }

    this.authService.sendOtp(phoneNumber).subscribe({
      next: (response: any) => {
        console.log('(v) Resend OTP th√†nh c√¥ng:', response);
        this.startCountdown();
        this.isLoading = false;
      },
      error: (error: any) => {
        console.error('(x) L·ªói resend OTP:', error);
        this.otpError = 'Kh√¥ng th·ªÉ g·ª≠i l·∫°i m√£ OTP. Vui l√≤ng th·ª≠ l·∫°i.';
        this.isLoading = false;
      },
    });
  }

  private resendForgotPasswordOtp(): void {
    const phoneNumber = sessionStorage.getItem('forgotPasswordPhone');
    if (!phoneNumber) {
      this.otpError = 'Kh√¥ng t√¨m th·∫•y s·ªë ƒëi·ªán tho·∫°i';
      this.isLoading = false;
      return;
    }

    this.authService.sendForgotPasswordOtp(phoneNumber).subscribe({
      next: (response: any) => {
        console.log('(v) Resend forgot password OTP th√†nh c√¥ng:', response);
        this.startCountdown();
        this.isLoading = false;
      },
      error: (error: any) => {
        console.error('(x) L·ªói resend forgot password OTP:', error);
        this.otpError = 'Kh√¥ng th·ªÉ g·ª≠i l·∫°i m√£ OTP. Vui l√≤ng th·ª≠ l·∫°i.';
        this.isLoading = false;
      },
    });
  }

  // X·ª¨ L√ù INPUT EVENT
  onInput(event: Event, index: number): void {
    const input = event.target as HTMLInputElement;
    let value = input.value;

    // console.log(
    //   'üìù [INPUT] √î',
    //   index,
    //   '| Value:',
    //   `"${value}"`,
    //   '| Last:',
    //   this.lastInputValue[index]
    // );

    // Ki·ªÉm tra OTP h·∫øt h·∫°n
    if (this.isOtpExpired()) {
      input.value = '';
      this.otpDigits[index] = '';
      this.lastInputValue[index] = '';
      this.otpError = 'M√£ OTP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng y√™u c·∫ßu m√£ m·ªõi.';
      this.showErrorState();
      setTimeout(() => {
        this.hideErrorState();
        this.clearOtpInputs();
      }, 1000);
      return;
    }

    // L·ªçc ch·ªâ l·∫•y s·ªë
    const numericValue = value.replace(/\D/g, '');

    // Tr∆∞·ªùng h·ª£p r·ªóng
    if (!numericValue) {
      this.otpDigits[index] = '';
      this.lastInputValue[index] = '';
      input.value = '';
      return;
    }

    // T√¨m k√Ω t·ª± m·ªõi ƒë∆∞·ª£c th√™m v√†o
    let newDigit = '';

    if (numericValue.length === 1) {
      newDigit = numericValue;
    } else {
      // N·∫øu c√≥ nhi·ªÅu k√Ω t·ª±, t√¨m k√Ω t·ª± kh√°c v·ªõi last value
      for (let i = 0; i < numericValue.length; i++) {
        if (numericValue[i] !== this.lastInputValue[index]) {
          newDigit = numericValue[i];
          break;
        }
      }
      // N·∫øu kh√¥ng t√¨m th·∫•y, l·∫•y k√Ω t·ª± cu·ªëi
      if (!newDigit) {
        newDigit = numericValue[numericValue.length - 1];
      }
    }

    // console.log('üî¢ [INPUT] New digit:', newDigit);

    // C·∫≠p nh·∫≠t gi√° tr·ªã
    this.otpDigits[index] = newDigit;
    this.lastInputValue[index] = newDigit;
    input.value = newDigit;

    // Clear error
    this.otpError = '';

    // console.log('‚úÖ [INPUT] Updated √¥', index, '=', newDigit);
    // console.log('üìã [INPUT] OTP:', this.otpDigits.join(''));

    // Focus √¥ ti·∫øp theo
    if (index < this.OTP_LENGTH - 1) {
      setTimeout(() => this.focusInput(index + 1), 10);
    }

    // Auto-verify khi ƒë·ªß 6 s·ªë
    if (this.otpDigits.every((d) => d !== '')) {
      console.log('ƒê·ªß 6 s·ªë ‚Üí Verify');
      setTimeout(() => this.verifyOtp(), 100);
    }
  }

  // X·ª¨ L√ù KEYDOWN
  onKeyDown(event: KeyboardEvent, index: number): void {
    const key = event.key;

    // console.log('‚å®Ô∏è [KEYDOWN] Key:', key, '| √î:', index);

    // Backspace
    if (key === 'Backspace') {
      event.preventDefault();

      // X√≥a √¥ hi·ªán t·∫°i
      this.otpDigits[index] = '';
      this.lastInputValue[index] = '';
      const input = event.target as HTMLInputElement;
      input.value = '';

      // console.log('üóëÔ∏è [KEYDOWN] X√≥a √¥', index);

      // Ki·ªÉm tra xem t·∫•t c·∫£ c√°c √¥ ƒë√£ tr·ªëng ch∆∞a
      const allEmpty = this.otpDigits.every((digit) => digit === '');

      if (allEmpty) {
        // N·∫øu t·∫•t c·∫£ ƒë√£ tr·ªëng, focus v·ªÅ √¥ ƒë·∫ßu ti√™n
        // console.log('üéØ [KEYDOWN] T·∫•t c·∫£ √¥ ƒë√£ tr·ªëng ‚Üí Focus √¥ ƒë·∫ßu');
        setTimeout(() => this.focusInput(0), 10);
      } else if (index > 0) {
        // N·∫øu ch∆∞a tr·ªëng h·∫øt, quay l·∫°i √¥ tr∆∞·ªõc
        setTimeout(() => this.focusInput(index - 1), 10);
      } else {
        // N·∫øu ƒë√£ ·ªü √¥ ƒë·∫ßu, focus l·∫°i √¥ ƒë·∫ßu
        setTimeout(() => this.focusInput(0), 10);
      }
      return;
    }

    // Delete
    if (key === 'Delete') {
      event.preventDefault();
      this.otpDigits[index] = '';
      this.lastInputValue[index] = '';
      const input = event.target as HTMLInputElement;
      input.value = '';
      // console.log('üóëÔ∏è [KEYDOWN] Delete √¥', index);
      return;
    }

    // Arrow keys
    if (key === 'ArrowLeft' && index > 0) {
      event.preventDefault();
      this.focusInput(index - 1);
      return;
    }

    if (key === 'ArrowRight' && index < this.OTP_LENGTH - 1) {
      event.preventDefault();
      this.focusInput(index + 1);
      return;
    }

    // Enter
    if (key === 'Enter') {
      event.preventDefault();
      this.verifyOtp();
      return;
    }

    // Tab
    if (key === 'Tab') {
      return;
    }

    // Ch·∫∑n k√Ω t·ª± kh√¥ng ph·∫£i s·ªë
    if (!/^\d$/.test(key) && !event.metaKey && !event.ctrlKey) {
      event.preventDefault();
    }
  }

  onPaste(event: ClipboardEvent): void {
    event.preventDefault();

    // console.log('üìã [PASTE] Detected');

    if (this.isOtpExpired()) {
      this.otpError = 'M√£ OTP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng y√™u c·∫ßu m√£ m·ªõi.';
      this.showErrorState();
      setTimeout(() => {
        this.hideErrorState();
        this.clearOtpInputs();
      }, 1000);
      return;
    }

    const pastedData = event.clipboardData?.getData('text') || '';
    const numbers = pastedData.replace(/\D/g, '');

    // console.log('üìã [PASTE] Numbers:', numbers);

    if (numbers.length > 0) {
      for (let i = 0; i < Math.min(numbers.length, this.OTP_LENGTH); i++) {
        this.otpDigits[i] = numbers[i];
        this.lastInputValue[i] = numbers[i];
        const inputElement = this.otpInputs.toArray()[i];
        if (inputElement?.nativeElement) {
          inputElement.nativeElement.value = numbers[i];
        }
      }

      this.otpError = '';

      const focusIndex = Math.min(numbers.length, this.OTP_LENGTH - 1);
      this.focusInput(focusIndex);

      if (numbers.length >= this.OTP_LENGTH) {
        // console.log('‚ú® [PASTE] ƒê·ªß 6 s·ªë ‚Üí Verify');
        setTimeout(() => this.verifyOtp(), 100);
      }
    }
  }

  onSubmit(): void {
    this.verifyOtp();
  }

  private focusInput(index: number): void {
    setTimeout(() => {
      if (this.otpInputs && this.otpInputs.length > index) {
        const input = this.otpInputs.toArray()[index];
        if (input?.nativeElement) {
          input.nativeElement.focus();
          input.nativeElement.select();
        }
      }
    }, 0);
  }

  verifyOtp(): void {
    if (this.isVerifying) {
      console.log('Already verifying, skip');
      return;
    }

    const otpCode = this.otpDigits.join('');

    console.log('>>> [VERIFY] OTP v·ª´a nh·∫≠p:', otpCode);
    console.log('>>> [VERIFY] OTP t·ª´ server:', this.currentOtp);

    if (otpCode.length !== this.OTP_LENGTH) {
      this.otpError = 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß 6 s·ªë OTP';
      return;
    }

    this.isVerifying = true;
    this.otpError = '';

    // KI·ªÇM TRA OTP C·ª§C B·ªò (cho testing)
    if (otpCode === this.currentOtp) {
      // console.log('‚úÖ [VERIFY] Local OTP match!');

      // Show success
      this.showSuccessState();

      // Set session storage
      if (this.flowType === 'register') {
        sessionStorage.setItem('registerOtpVerified', 'true');
        sessionStorage.setItem('registerOtp', otpCode);

        setTimeout(() => {
          this.router.navigate(['/register/password']);
        }, this.SUCCESS_DELAY);
      } else {
        sessionStorage.setItem('forgotPasswordOtpVerified', 'true');
        sessionStorage.setItem('forgotPasswordOtp', otpCode);

        setTimeout(() => {
          this.router.navigate(['/forgot-password/reset']);
        }, this.SUCCESS_DELAY);
      }

      return;
    }

    // N·∫øu kh√¥ng match local, g·ªçi API
    // console.log('‚ö†Ô∏è [VERIFY] Local mismatch, calling API...');

    if (this.flowType === 'register') {
      this.verifyRegistrationOtp(otpCode);
    } else if (this.flowType === 'forgot') {
      this.verifyForgotPasswordOtp(otpCode);
    }
  }

  private verifyRegistrationOtp(otpCode: string): void {
    // console.log('üîÑ Verifying registration OTP via API...');

    this.authService.verifyOtp(this.phoneNumber, otpCode).subscribe({
      next: (response: any) => {
        console.log('>>> Registration OTP verified successfully:', response);

        this.showSuccessState();

        sessionStorage.setItem('registerOtpVerified', 'true');
        sessionStorage.setItem('registerOtp', otpCode);

        setTimeout(() => {
          this.router.navigate(['/register/password']);
        }, this.SUCCESS_DELAY);
      },
      error: (error: any) => {
        console.error('Registration OTP verification failed:', error);
        this.handleOtpError(error);
      },
    });
  }

  private verifyForgotPasswordOtp(otpCode: string): void {
    // console.log('üîÑ Verifying forgot password OTP via API...');

    this.authService.verifyForgotPasswordOtp(this.phoneNumber, otpCode).subscribe({
      next: (response: any) => {
        console.log('>>> Forgot password OTP verified successfully:', response);

        this.showSuccessState();

        sessionStorage.setItem('forgotPasswordOtpVerified', 'true');
        sessionStorage.setItem('forgotPasswordOtp', otpCode);

        setTimeout(() => {
          this.router.navigate(['/forgot-password/reset']);
        }, this.SUCCESS_DELAY);
      },
      error: (error: any) => {
        console.error('Forgot password OTP verification failed:', error);
        this.handleOtpError(error);
      },
    });
  }

  private handleOtpError(error: any): void {
    this.isVerifying = false;

    if (error.status === 400) {
      this.otpError = 'M√£ OTP kh√¥ng ch√≠nh x√°c. Vui l√≤ng ki·ªÉm tra l·∫°i.';
    } else if (error.status === 404) {
      this.otpError = 'M√£ OTP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng y√™u c·∫ßu m√£ m·ªõi.';
    } else {
      this.otpError = 'C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.';
    }

    this.showErrorState();

    setTimeout(() => {
      this.hideErrorState();
      this.clearOtpInputs();
    }, 1000);
  }

  canResendOtp(): boolean {
    return this.countdown <= 0 && !this.isLoading;
  }

  getDisplayPhoneNumber(): string {
    if (this.phoneNumber === 'Unknown') {
      return 's·ªë ƒëi·ªán tho·∫°i c·ªßa b·∫°n';
    }
    return this.phoneNumber;
  }

  getTitle(): string {
    return this.flowType === 'register' ? 'X√°c th·ª±c ƒëƒÉng k√Ω' : 'X√°c th·ª±c qu√™n m·∫≠t kh·∫©u';
  }

  getDescription(): string {
    return this.flowType === 'register'
      ? 'Nh·∫≠p m√£ OTP ƒë√£ g·ª≠i ƒë·∫øn s·ªë ƒëi·ªán tho·∫°i c·ªßa b·∫°n ƒë·ªÉ ho√†n t·∫•t ƒëƒÉng k√Ω'
      : 'Nh·∫≠p m√£ OTP ƒë√£ g·ª≠i ƒë·∫øn s·ªë ƒëi·ªán tho·∫°i c·ªßa b·∫°n ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u';
  }

  showErrorState(): void {
    // console.log('üî¥ Showing error state');
    setTimeout(() => {
      const otpInputs = document.querySelectorAll('.otp-digit');
      otpInputs.forEach((input) => {
        input.classList.add('error-state');
        (input as HTMLElement).style.borderColor = '#e53935';
        (input as HTMLElement).style.backgroundColor = '#ffebee';
        (input as HTMLElement).style.boxShadow = '0 0 0 3px rgba(229, 57, 53, 0.2)';
      });
    }, 10);
  }

  showSuccessState(): void {
    // console.log('üü¢ Showing success state');
    setTimeout(() => {
      const otpInputs = document.querySelectorAll('.otp-digit');
      otpInputs.forEach((input) => {
        input.classList.add('success-state');
        (input as HTMLElement).style.borderColor = '#28a745';
        (input as HTMLElement).style.backgroundColor = '#d4edda';
        (input as HTMLElement).style.boxShadow = '0 0 0 3px rgba(40, 167, 69, 0.2)';
      });
    }, 10);
  }

  hideErrorState(): void {
    // console.log('üîÑ Hiding error state');
    const otpInputs = document.querySelectorAll('.otp-digit');
    otpInputs.forEach((input) => {
      input.classList.remove('error-state');
      (input as HTMLElement).style.borderColor = '';
      (input as HTMLElement).style.backgroundColor = '';
      (input as HTMLElement).style.boxShadow = '';
    });
  }

  hideSuccessState(): void {
    // console.log('üîÑ Hiding success state');
    const otpInputs = document.querySelectorAll('.otp-digit');
    otpInputs.forEach((input) => {
      input.classList.remove('success-state');
      (input as HTMLElement).style.borderColor = '';
      (input as HTMLElement).style.backgroundColor = '';
      (input as HTMLElement).style.boxShadow = '';
    });
  }

  private clearOtpInputs(): void {
    // console.log('üßπ Clearing all OTP inputs');
    this.otpDigits = ['', '', '', '', '', ''];
    this.lastInputValue = ['', '', '', '', '', ''];
    this.isVerifying = false;

    if (this.otpInputs) {
      this.otpInputs.forEach((input) => {
        if (input.nativeElement) {
          input.nativeElement.value = '';
        }
      });
    }

    setTimeout(() => this.focusInput(0), 100);
  }

  private isOtpExpired(): boolean {
    return this.countdown <= 0;
  }
}
